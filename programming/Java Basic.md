### 原码、反码、补码

## 缘起

一次在写测试程序的时候，随手对2取了一个反，当时代码大意如下:

```
public static void main(String[] args) {
        int a = 2;
        System.out.println(~a);
    }
```

按照我当时的想法，觉得过程应该是这样的:

1. a = 2,也就是说a的二进制位10，取反就变成了01，所以结果应该为1。
2. 但是实际的结果值是-3，于是就被打脸了。

## 知识普及

那究竟是为什么结果和我预期的不一致呢？这就要从计算机常用的几个码说起了。首先，java存储的是有符号数，在计算机中，有符号数通常是使用补码存储的，java也不例外。先来看看什么叫原码，反码，补码。

### 原码

原码就是符号位加上真值的绝对值,即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:

> [+1]原 = 0000 0001

[-1]原 = 1000 0001

第一位是符号位. 正数符号位为0，负数为1。

### 反码

正数的反码是其本身
负数的反码是在其原码的基础上,符号位不变，其余各个位取反.
例如：

> [+1] = [00000001]原 = [00000001]反

[-1] = [10000001]原 = [11111110]反

### 补码

正数的补码就是其本身
负数的补码是在反码的基础上+1。
例如:

> [+1] = [00000001]原 = [00000001]反 = [00000001]补

[-1] = [10000001]原 = [11111110]反 = [11111111]补

## 分析

所以回到一开始的问题，`int a = 2` a在计算机中是以补码存储的。

- 对于2这个正数来说，补码、反码、原码都是相同的，又由于是数值型，在这里我先用八位bit来表示一下：

> 原码:0000 0010
> 反码:0000 0010

补码:0000 0010

- 取反
  取反过程是在补码的基础上进行的，由于是按位取反，无论符号位还是数值位都要取反，所以结果如下:

> 取反后的补码: 1111 1101

- 换算为值
  那么取反后的补码的实际值是多少呢？我们需要先把他转化为原码，过程如下:

> 反码 = 1111 1101 - 1 = 1111 1100

原码 = 反码符号位不变，其余取反 = 1000 0011

所以，最后的值-3